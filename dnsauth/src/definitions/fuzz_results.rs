//! Output results from the fuzzer.
//!
//! These types are used to record the results of fuzzing different implementations.
//! Each query/response pair has its own [`FuzzResult`] and can be grouped together into a [`FuzzResultSet`].

use super::{CacheKey, FuzzCaseId, FuzzSuiteId, ResolverName};
use crate::serialize::DnsWireFormatB64;
use crate::MessageExt as _;
use chrono::{DateTime, Utc};
use fuzzer_protocol::Counters;
use std::collections::BTreeMap;
use std::fmt;
use trust_dns_proto::op::Message;

/// Results generated by the fuzzer
///
/// The results are
#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct FuzzResultSet {
    /// Corresponding [`FuzzSuite`] ID
    pub id: FuzzSuiteId,
    /// Identifies the fuzzed program
    pub fuzzee: ResolverName,

    /// Start of the experiment period
    pub time_start: DateTime<Utc>,
    /// End of the experiment period
    pub time_end: DateTime<Utc>,
    /// Background noise profile
    ///
    /// Some fuzzees have background processes, e.g., to cleanup the cache.
    /// This can introduce noise into the results which might want to be handled later on.
    /// This field contains the noise profile.
    pub background_activity: Option<Counters>,
    /// Results after running all the individual [`FuzzCases`].
    pub results: Vec<FuzzResult>,

    /// Extra meta information attached to the fuzz result.
    ///
    /// **NOTE**: This field is not serialized and only used for internal purposes.
    #[serde(skip, default)]
    pub meta: BTreeMap<String, std::sync::Arc<dyn std::any::Any + Send + Sync + 'static>>,
}

/// Results after fuzzing a single [`FuzzCase`].
#[serde_with::serde_as]
#[derive(Debug, Clone, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FuzzResult {
    /// Identifies the specific [`FuzzCase`].
    pub id: FuzzCaseId,

    /// Counter results for an instrumented fuzzee.
    ///
    /// Since not all fuzzees are instrumented, this may be empty.
    pub counters: Option<Counters>,
    /// Caching state after the fuzzing.
    pub cache_state: CacheState,
    /// DNS response to the simulated DNS client.
    #[serde_as(as = "Option<DnsWireFormatB64>")]
    pub fuzzee_response: Option<Message>,
    /// All DNS queries issued towards the AuthNS.
    #[serde_as(as = "Vec<DnsWireFormatB64>")]
    pub fuzzee_queries: Vec<Message>,
    /// Index of the DNS response served to the client.
    ///
    /// The index refers to the [`FuzzCase::server_responses`] vector.
    /// A value of `usize::MAX` indicates that no response was served.
    pub response_idxs: Vec<usize>,
    pub oracles: OracleResults,
}

/// Results of the oracles.
///
/// See GitLab #24 for more information.
#[derive(Debug, Copy, Clone, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OracleResults {
    /// Did the resolver crash while processing this query?
    pub crashed_resolver: bool,
    /// Many queries to the AuthNS? This indicates a looping bug or query amplification potential.
    pub excessive_queries: bool,
    /// Too many records in the returned client answer? This indicates amplification vulnerabilities or looping bugs.
    pub excessive_answer_records: bool,
    /// Did the resolver return duplicate records?
    pub duplicate_records: bool,
    /// Did the resolver return fake data? This can indicate some bug in the record processing or special handling in a specific resolver.
    pub fake_data: bool,
    /// A response was served to the client, even though the query had QR=1
    ///
    /// This can lead to a traffic loop, when two resolvers keep sending responses to each other, since there is no counter or timeout to make them stop.
    /// CVE-2012-0206 https://doc.powerdns.com/md/security/powerdns-advisory-2012-01/
    pub responds_to_response: bool,
}

impl OracleResults {
    /// Returns `true` if any of the oracles returned `true`.
    pub fn has_any_set(&self) -> bool {
        !matches!(
            self,
            Self {
                crashed_resolver: false,
                excessive_queries: false,
                excessive_answer_records: false,
                duplicate_records: false,
                fake_data: false,
                responds_to_response: false,
            }
        )
    }
}

/// Describes the important parts of the fuzzees cache after running a [`FuzzCase`].
#[serde_with::serde_as]
#[derive(Debug, Clone, PartialEq, Eq, serde::Deserialize, serde::Serialize)]
pub struct CacheState {
    #[serde_as(as = "Vec<(_, _)>")]
    pub values: BTreeMap<CacheKey, CachePresent>,
}

/// What is the state of the (potentially) cached records.
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Deserialize, serde::Serialize,
)]
pub enum CachePresent {
    Present,
    Absent,
    Error,
}

impl fmt::Debug for FuzzResultSet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FuzzResultSet")
            .field("id", &self.id)
            .field("fuzzee", &self.fuzzee)
            .field("time_start", &self.time_start)
            .field("time_end", &self.time_end)
            .field("background_activity", &self.background_activity)
            .field("results", &self.results)
            .finish()
    }
}

impl fmt::Display for FuzzResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "FuzzResult({})", self.id)?;
        if let Some(counters) = &self.counters {
            write!(f, " {counters:?}")?;
        }
        let cache_summarized =
            self.cache_state
                .values
                .values()
                .fold(BTreeMap::new(), |mut acc, &present| {
                    *acc.entry(present).or_insert(0) += 1;
                    acc
                });
        write!(f, " Cache")?;
        for (present, count) in cache_summarized.iter() {
            write!(f, " {present:?} {count}")?;
        }
        write!(f, " Resp ")?;
        if let Some(response) = &self.fuzzee_response {
            write!(f, "{}", response.display_short())?;
        } else {
            write!(f, "<None>")?;
        }
        write!(f, " AuthNS-#Q {}", self.fuzzee_queries.len())?;
        Ok(())
    }
}

/// Implements [`Display`] and prints basic statistics (min/med/avg/max) of a vector of numbers.
struct BasicStats<'a>(&'a [u32]);

impl fmt::Display for BasicStats<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut data = self.0.to_vec();
        data.sort_unstable();
        let min = data[0];
        let max = data[data.len() - 1];
        let median = data[data.len() / 2];
        let mean = data.iter().map(|&x| x as f64).sum::<f64>() / data.len() as f64;
        write!(f, "{min} / {median} / {mean} / {max}")
    }
}
